{
    "noir_version": "1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a",
    "hash": 2222954932595864338,
    "abi": {
        "parameters": [
            {
                "name": "user1",
                "type": {
                    "kind": "struct",
                    "path": "structs::User",
                    "fields": [
                        {
                            "name": "id",
                            "type": {
                                "kind": "field"
                            }
                        },
                        {
                            "name": "age",
                            "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 8
                            }
                        },
                        {
                            "name": "gender",
                            "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 8
                            }
                        },
                        {
                            "name": "region",
                            "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 8
                            }
                        },
                        {
                            "name": "interests",
                            "type": {
                                "kind": "array",
                                "length": 3,
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 8
                                }
                            }
                        },
                        {
                            "name": "preferences",
                            "type": {
                                "kind": "struct",
                                "path": "structs::Preferences",
                                "fields": [
                                    {
                                        "name": "age_min",
                                        "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 8
                                        }
                                    },
                                    {
                                        "name": "age_max",
                                        "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 8
                                        }
                                    },
                                    {
                                        "name": "gender",
                                        "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 8
                                        }
                                    }
                                ]
                            }
                        }
                    ]
                },
                "visibility": "private"
            },
            {
                "name": "user2",
                "type": {
                    "kind": "struct",
                    "path": "structs::User",
                    "fields": [
                        {
                            "name": "id",
                            "type": {
                                "kind": "field"
                            }
                        },
                        {
                            "name": "age",
                            "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 8
                            }
                        },
                        {
                            "name": "gender",
                            "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 8
                            }
                        },
                        {
                            "name": "region",
                            "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 8
                            }
                        },
                        {
                            "name": "interests",
                            "type": {
                                "kind": "array",
                                "length": 3,
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 8
                                }
                            }
                        },
                        {
                            "name": "preferences",
                            "type": {
                                "kind": "struct",
                                "path": "structs::Preferences",
                                "fields": [
                                    {
                                        "name": "age_min",
                                        "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 8
                                        }
                                    },
                                    {
                                        "name": "age_max",
                                        "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 8
                                        }
                                    },
                                    {
                                        "name": "gender",
                                        "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 8
                                        }
                                    }
                                ]
                            }
                        }
                    ]
                },
                "visibility": "private"
            }
        ],
        "return_type": {
            "abi_type": {
                "kind": "boolean"
            },
            "visibility": "public"
        },
        "error_types": {}
    },
    "bytecode": "H4sIAAAAAAAA/9VdaVMTQRDtHGgA8YIgIl4RRURgNhcbAUEQEEEQEPksmvwB/3+VNOyUnWXA0n2NM1OVWuiFx+vj9c4M2U2OzsbRyetn8nXu5FVIjvwqpWx5h63gsBUdth6H7ZrDdt1hKzlsvQ5bv8N2w2EbcNhuOmy3HLbbDtsdh+2uwzaY2Ioi3umRT47LydFkG5HEqplmvd6eq7ajWvTNVFvHccPUG8fNOIqjRtz4UY1rtXZcj+dax60504rqtXbUabRqnQSsD8fLSN/Lms6XwQEoC+Io3CL9Fph2QeSAvO+geEXGOFyHYcu4DifHe0Td6mRDKUWgGEjw/xWr3eFhomEgr3vAxP2NMLLyzgHzfJfCE8ZIcrxP1C0MNvxJGL4GP6swRoA+3qcwhXEdmJt+Ck8Yo8nxAVG3MNigLQyt4GcVxijQxwf0f4Rhso2oBIxBiMIYS44PibqFwQbtqZRW8LMKYwzI6yG4KHLgHIwmRZDGzer3IxxHFb95ujyi4PdjsN92FMD+9wJ9vgHEegKM32WbNOh6QvKWfJ9qEn6qgFsBFoOW3xURYBDulRYbQrxnF7tOR/J9pkmYwVHrGkv+GZDjuOeFyzEcJ9wVy8ZwnK7mipU1pnlgLAeBvJ5TmE0EyVvyfaFJ+IUC7gT5LXz2e0IEGIR7pcWGEJzrivVSkzCDo69YL4EcJz0vXI7hJOGvWJOEvWKh14ATid/oNduEp7XzyvN88HR/XCEfFfJz9jmlnA+TbUS8N/RYIc+vPfebdTKl4Pc0YScFF22+o+NRgGF1vjvoqmyYzyTHWRsQu2HOhvSGObrhFAh1ETXRDLAAZ5USiRbKDGEbhM95tj4PALEMYRuNzPFleTfZRoTkLflGmoQjBdwqsBi0/K6KAINwVbjybGOa8E2qRlfTpBDveETF8iaQV53CbFJI3pJvQ5NwQwG3SX43Kfa7KQIMwg1GrLeAvOYoTLEieUu+sSbhWAG3RX6Llf1uiQCDcIMR620grzcUpliRvCXfeU3C8wq4C+S3WNnvBRFgEK7KpjLPALixoNf+TfKzOS9SGM2zBxg/5LLkLYXZPJG8Jd8lTcJLCrjL5HfzlIkC4gYjVuSy5B2FKVYkb8l3RZPwigLuKvktVvZ7VQQYhBuMWJHLkvcUpliRvCXfNU3Cawq46+S3WNnvdRFgEK7KsoRxuLGglyXL5Gdz3lDOh8k2Tmt7g/DNGKmZDSDWB2DsNPTB2wuLCvpYAGItAv3dpDAmF9eA8UMu2z9SmJMLJG/Jd0uT8JYC7jb5Pblgv7dFgEG4wYgVuWz/RGGKFclb8t3RJLyjgLtLfouV/d4VAQbhBiNW5LL9M4UpViRvyXdPk/CeAu4++S1W9ntfBBiEq7Js5xkANxb0smSb/GzOB8r5MNnGaW0fEL4ZIzVzAMT6AowdY+TBcbPbKCiOvE2xqaC3dSAWclvmkPzWG7/pu0b4vvoV7De6rm2fQcWRdXyoUNf7QCxk3zoC59cOdB2OEra/avEcC4TncCA8R8A8NZ59wbeCo/sa8pkawNv9VWJYobPby9ExrACxgA/56dJLHhxLrTsfTcYhfUbXzxHQZxc/xBzqSMHvIWB+mJvdBBpK5YprtJCc5/ew8IaY/YwKfqgWfyQAPz6UH2PINcP/PuJdad7s4ie088OoB+l8/uXfsTroTR3L4ndwt7ufPQxMcgDjnz6zOD3kxyYMpfzMi3PLIA4Wz85le+j8yKfO2Z8tpfjl8PyiNJeC42/ZYetH1kz5Aq59AgeY06rF79fBd9ZMn/i6P3XO5q7o+L3cBd/nU8fLfvayzeABxzmLaXMl+Vo/fgEB1uCDdGcAAA==",
    "debug_symbols": "1ZrbbuIwEIbfJddceHyYA6+yWlUcQhUJAeKw0gr13ZcgnEUmtGrSqTp3OJ7/05+Q8W8LztWynp9eX5rNanuopr/O1Xq7mB2b7eYyOlfA12uH3WzTDg/H2f5YTSESTKp6s2w/CrxNqlWzrqsp+rffkwrk8xrvejUpUtYkcveayWMx4q3Wu1DiQRfvdfFhNN47zviYSnzUxSddPI7GB0i32pB8iSddPOviZTw+5dogscAHp4sHXbz/gmcfO3z5Yoagi3/StZxbBRDi+/iEuRYdl/iki0ddPOnieTQeIWR8LLs2iCo+Ol08jMYT+FstPSxp0evigy4+6uLHdy11KyYxlnjUxZMunr/g2UOHpxIvqvj0pGsJn+BbDQzQ9PcXBt9pkN+/DcmpBf6uEq70oEqPqvSkSsfRdKDYnSF8iSddPOviRRWP/b2F3j3Bt5r+3kLueosgffA2cOaLyAc7QXR5aQgI/1e20HenznWvmYNyHUFv1Hcw6jsa9Z2M+kajvsmobzbqW2z6JmfUt9G8JKN5Sd+bl6nb2ha+WytGI5CMRiAZjUAyGoFkNALJaASy0QhkoxHIRiOQjR4Z2WhestG8ZPwxWyVWjMAWz7p4o4EiRgNFjAaKGA0UMRooYjRQxGigiNEDmBg9gInRA5gYzcvLrFXj8GO2euC86mYMXFDmP0mV7ofWkn8VpSGi/vWUvHSi8PhV0xARDxHJABG4ISIYIvJDROGzostgvm/W6+b15f4v5JfLf2b7ZjZf17fh6rRZ3M0e/+7yTNbv9ttFvTzt65Z0nbvg/wE=",
    "file_map": {
        "3": {
            "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n",
            "path": "std/array/mod.nr"
        },
        "61": {
            "source": "use crate::structs::User;\n\npub fn check_region(user1: User, user2: User) -> bool {\n    assert(user1.region < regions.len() as u8);\n    let mut is_match: bool = true;\n\n    if user1.region != user2.region {\n        is_match = false;\n    }\n\n    is_match\n}\n\nglobal regions: [u8; 4] = [\n    001, // Africa\n    002, // Americas\n    003, // Asia\n    004, // Europe\n];\n",
            "path": "/app/src/location.nr"
        },
        "62": {
            "source": "mod structs;\nmod location;\n\nuse structs::User;\n\nfn check_age(user1: User, user2: User) -> bool {\n    let mut is_match: bool = true;\n\n    // user1 preferences\n    if (user1.age < user2.preferences.age_min) | (user1.age > user2.preferences.age_max) {\n        is_match = false;\n    }\n\n    // user2 preferences\n    if (user2.age < user1.preferences.age_min) | (user2.age > user1.preferences.age_max) {\n        is_match = false;\n    }\n\n    is_match\n}\n\nfn check_gender(user1: User, user2: User) -> bool {\n    let mut is_match: bool = true;\n\n    // user1 preferences\n    if (user1.preferences.gender != user2.gender) & (user1.preferences.gender != 2) {\n        is_match = false;\n    }\n\n    // user2 preferences\n    if (user2.preferences.gender != user1.gender) & (user2.preferences.gender != 2) {\n        is_match = false;\n    }\n\n    is_match\n}\n\nfn check_interests(user1: User, user2: User) -> bool {\n    let mut is_match: bool = false;\n\n    for interest in user1.interests {\n        if user2.interests.any(|i| i == interest) {\n            is_match = true;\n        }\n    }\n    is_match\n}\n\nfn main(user1: User, user2: User) -> pub bool {\n    // removed hash to make circuit smaller\n    // let id_nullifier_hash1 = std::hash::poseidon2::Poseidon2::hash([user1.id_nullifier], 1);\n    // let id_nullifier_hash2 = std::hash::poseidon2::Poseidon2::hash([user2.id_nullifier], 1);\n    // assert(user1.id == id_nullifier_hash1);\n    // assert(user2.id == id_nullifier_hash2);\n    assert(user1.id != user2.id);\n\n    let mut is_match: bool = true;\n\n    is_match &= check_age(user1, user2);\n    is_match &= check_gender(user1, user2);\n    is_match &= location::check_region(user1, user2);\n    is_match &= check_interests(user1, user2);\n\n    assert(is_match);\n    is_match\n}\n",
            "path": "/app/src/main.nr"
        }
    },
    "names": [
        "main"
    ],
    "brillig_names": [
        "directive_invert",
        "directive_integer_quotient"
    ]
}