{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":11270627638300969640,"abi":{"parameters":[{"name":"user1","type":{"kind":"struct","path":"structs::User","fields":[{"name":"id","type":{"kind":"field"}},{"name":"id_nullifier","type":{"kind":"field"}},{"name":"age","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"gender","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"region","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"interests","type":{"kind":"array","length":3,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"preferences","type":{"kind":"struct","path":"structs::Preferences","fields":[{"name":"age_min","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"age_max","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"gender","type":{"kind":"integer","sign":"unsigned","width":8}}]}}]},"visibility":"private"},{"name":"user2","type":{"kind":"struct","path":"structs::User","fields":[{"name":"id","type":{"kind":"field"}},{"name":"id_nullifier","type":{"kind":"field"}},{"name":"age","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"gender","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"region","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"interests","type":{"kind":"array","length":3,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"preferences","type":{"kind":"struct","path":"structs::Preferences","fields":[{"name":"age_min","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"age_max","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"gender","type":{"kind":"integer","sign":"unsigned","width":8}}]}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/9VcCVdTOxCeLijLw43i8t7zPRERN+TeLnDrCm6guIELbqD22P4B/7/HO5AcxzTqkftNTXJOmjq9fHwzyTdZpCnRbunk9bN5X8prxbTlvA47torHVvXYhjy2fR7bfo9t2GMb8dhGPbZxj+2Ax3bQYzvksR322I54bBMeW81jmzQ2WUqmXTJtI1loNruL9W7aSD8m9XYnayXNVmchS7O0lbU+1bNGo5s1s8V2p72YtNNmo5v2Wu1GL9ktxwRWUrBo8jy+d56pa7D9UhVcuX4x7bEfvD9u3tufO5HXv/P6T17/NXYf9l97wD6Z1//y+n9eTwm7LWUnvkmxkiL76gTpjCm0z2NAn08Cfa46/mrGoAyMwQSKV/p9vxPS5xxbxnXKtKf5RSbfKfqWGKyNH3ITcjWSDtkrVrfHJUmngLxOAzvzd8RSlHcZ2M81ik8s06Y9wy9SGNPULxZ+6FdiCbVDioplGujjGYpTLMPAvhmn+MQyY9qz/CKFMUP9YuGHtMWi1SFFxTID9PEs/RmxJMVKOgKMQYximTXtOX6RwpilfrHwQ9rLMK0OKSqWWSCvc+CBUgL3wYzofwL6fR7HUcVvXmpPK/h9Aey3LRWw/6NAnw8AsS4C42fPikrUX9DjCclb8r2kSfiSAu4ccDBo+T0nAgzCHehgQ4h3d7Lr9STfy5qEGRy1/7HkLwM5zgc+cDmG84SbsWwM52kwM1bRmFaAsZwE8kooziSC5C35ppqEUwXcOoUtfAatiwCDcAc62BCC881YDU3CDI6esRpAjs3ABy7HsEn4GatJ2BkLvQesG7/Re7Z6oGOnFXh/8HJ/XqE/5ijM1eeCcn8kxUrKZ0MXFPp5MXC/WScLCn5nhF0UcLHznizoeFRhWDtTQl+BYDuH6G3TXrEBsQfmbHAPzNEJp0qoSTRJ24QbgFeUOhItlDZhE0TI/Wx9PgjEukrYRDOo3QeSt+R7TZPwNQXc68DBoOX3dRFgEK4KV15tZIRPUjdoMEmqKM8hYCwPAXndpDiTFJK35LukTRiNu0xhJyn2e9kT4KRgEZBBi/UwkNctilOsSN6S721NwrcVcO9Q2GJlv++IAINwoxHrESCvuxSnWJG8Jd97moTvKeCuUNhiZb9XRIBBuCqHyrwC4MSC3vsvU5jJeZXiSJ77gPFDbkvuU5zJE8lb8n2gSfiBAu4ahZ082e81EWAQbjRiRW5LHlKcYkXylnwfaRJ+pID7mMIWK/v9WAQYhBuNWJHbkicUp1iRvCXfp5qEnyrgrlPYYmW/10WAQbgq2xJeAXBiQW9L1ijM5Lyh3B9JsbIztjcIn4yRmtkAYj0Dxk5DH3y8sKqgjxUg1irQ3+cUx+JiPzB+yG37C4pzcYHkLfm+1CT8UgF3k8JeXLDfmyLAINxoxIrctr+iOMWK5C35vtYk/FoB9w2FLVb2+40IMAg3GrEit+1vKU6xInlLvu80Cb9TwN2isMXKfm+JAINwVbbtvALgxILelmxSmMl5W7k/kmJlZ2xvEz4ZIzWzDcR6D4wdY5TBcbPHKCiOfEzxXEFv60As5LHMBwpbb/xH3zcIn1c/gv1Gj2ubZ1BxZB1/UBjXW0AsZN7qUNjzOo+/joJejgL9Zm72a39H6VspmfFeMZ/znyXy/wHaK+L5+ja+lISveObrt/kKNr4Kir9xxEdwvLPnDQPfkMsXf0462O7vs9qy36IbMe2o+BngJSB1iz+mg7+z8XLLqHg/5nxm/a96fq70g3+XnfZnz/5sczTu+cxiTphW8rV+jDjtpMBFXthi8Ws6+N6+kuO15vgp470E4mDxbO4eov5Sdj6zz7qaKeH5pS6Xiud32WLHTE3YbDy/AiZ+1dnnYgAA","debug_symbols":"5ZvbauNADIbfxde5kGakOeRVlqXk4BRDSEIOC0vou68dMrNmaicUV6WidxmP9EVyrPmlgK/Vul5eXl+a3WZ/qua/rtV2v1qcm/2uXV0rDLdrp8Ni1y1P58XxXM0ROc6qerduPxqDb7Nq02zrau7M2+ydsWV3tyUD2dTwgKnxmLjGW/vYGL1PYPSRnxhDJiO40Df+Pasw/oQsDfyILHEwS8Mm+Vgk/VmawSyt8TlL9v0sOx877OMx+RBg6UODPsT5eyjA47uJLiVtwJZ4lsU7WbyXxYfJeAMh4YlLfBTFW5DFoyzeTMZb5LutZVPirSyeZPEsi59etTbb2kgl3svigyw+iuIJPuGnpYwvy4pQFj9StTEVOrJ5ov3skq2DUOKtLJ5k8SyLd5PxDm3CU3kokJfFB1l8nIz3mBpY/+7EZJDFoyzeyOKnV63P55MPrsSTLJ5l8e4T7j1mfDlysJfFj1RtcCP4zid+3McN1xdTninZh8dpRMpDds8Sb3QUpRtRuhWl02Q6esoDlinxLIt3sngvix+uLbYwgu98hmuLY64tZ/jJ0xASP8b4pBN0kI4G6/D/yWYH/02B/JgBlueIB6Vxo9K4jdK4rdK4SWncrDRupzRurzTuoDRupXoZlOpl+Fq95NzaFnF3oSiVwKBUAoNSCQxKJTAolcCgVAKDUgkMSiUwKpXAqHRkjEr1MirVy0jfplWKghLY4Z0sXqmgRKWCEpUKSrurNXClkoKgVFMQlIoKAmkNXOkYhqB0DkNQqpsISoUTIX6blg8RRJsyRBTmj0hLoBH+zcl+1KldLI/Ndtu8vvRf22gv/1kcm8VyW9+Xm8tu1ds9/z2kneR/OO5X9fpyrDvSba/F/wM=","file_map":{"3":{"source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n","path":"std/array/mod.nr"},"25":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"61":{"source":"use crate::structs::User;\n\npub fn check_region(user1: User, user2: User) -> bool {\n    assert(user1.region < regions.len() as u8);\n    let mut is_match: bool = true;\n\n    if user1.region != user2.region {\n        is_match = false;\n    }\n\n    is_match\n}\n\n// countries is too specific, so we use regions instead\n// the list is made up, with the help of ChatGPT\nglobal regions: [u8; 12] = [\n    001, // Northern Africa (ex: Egypt, Algeria, Morocco, ...)\n    002, // Sub-Saharan Africa (ex: Nigeria, Kenya, South Africa, ...)\n    003, // Middle East (ex: Israel, Saudi Arabia, Iran, ...)\n    004, // South Asia (ex: India, Pakistan, Bangladesh, ...)\n    005, // South-East Asia (ex: Indonesia, Vietnam, Philippines, ...)\n    006, // East Asia (ex: China, Japan, South Korea, ...)\n    007, // Central Asia (ex: Kazakhstan, Uzbekistan, Kyrgyzstan, ...)\n    008, // Eastern Europe (ex: Ukraine, Poland, Romania, ...)\n    009, // Western Europe (ex: France, Germany, Netherlands, ...)\n    010, // Southern Europe (ex: Italy, Spain, Greece, ...)\n    011, // North America (ex: United States, Canada, Mexico, ...)\n    012, // South America (ex: Brazil, Argentina, Colombia, ...)\n];\n\n// // ISO 3166-1\n// // https://www.iban.com/country-codes\n// global countries: [u16; 249] = [\n//     004, // Afghanistan\n//     008, // Albania\n//     010, // Antarctica\n//     012, // Algeria\n//     016, // American Samoa\n//     020, // Andorra\n//     024, // Angola\n//     028, // Antigua and Barbuda\n//     031, // Azerbaijan\n//     032, // Argentina\n//     036, // Australia\n//     040, // Austria\n//     044, // Bahamas\n//     048, // Bahrain\n//     050, // Bangladesh\n//     051, // Armenia\n//     052, // Barbados\n//     056, // Belgium\n//     060, // Bermuda\n//     064, // Bhutan\n//     068, // Bolivia (Plurinational State of)\n//     070, // Bosnia and Herzegovina\n//     072, // Botswana\n//     074, // Bouvet Island\n//     076, // Brazil\n//     084, // Belize\n//     086, // British Indian Ocean Territory\n//     090, // Solomon Islands\n//     092, // Virgin Islands (British)\n//     096, // Brunei Darussalam\n//     100, // Bulgaria\n//     104, // Myanmar\n//     108, // Burundi\n//     112, // Belarus\n//     116, // Cambodia\n//     120, // Cameroon\n//     124, // Canada\n//     132, // Cabo Verde\n//     136, // Cayman Islands\n//     140, // Central African Republic\n//     144, // Sri Lanka\n//     148, // Chad\n//     152, // Chile\n//     156, // China\n//     158, // Taiwan, Province of China\n//     162, // Christmas Island\n//     166, // Cocos (Keeling) Islands\n//     170, // Colombia\n//     174, // Comoros\n//     175, // Mayotte\n//     178, // Congo\n//     180, // Congo, Democratic Republic of the\n//     184, // Cook Islands\n//     188, // Costa Rica\n//     191, // Croatia\n//     192, // Cuba\n//     196, // Cyprus\n//     203, // Czechia\n//     204, // Benin\n//     208, // Denmark\n//     212, // Dominica\n//     214, // Dominican Republic\n//     218, // Ecuador\n//     222, // El Salvador\n//     226, // Equatorial Guinea\n//     231, // Ethiopia\n//     232, // Eritrea\n//     233, // Estonia\n//     234, // Faroe Islands\n//     238, // Falkland Islands (Malvinas)\n//     239, // South Georgia and the South Sandwich Islands\n//     242, // Fiji\n//     246, // Finland\n//     248, // Aland Islands\n//     250, // France\n//     254, // French Guiana\n//     258, // French Polynesia\n//     260, // French Southern Territories\n//     262, // Djibouti\n//     266, // Gabon\n//     268, // Georgia\n//     270, // Gambia\n//     275, // Palestine, State of\n//     276, // Germany\n//     288, // Ghana\n//     292, // Gibraltar\n//     296, // Kiribati\n//     300, // Greece\n//     304, // Greenland\n//     308, // Grenada\n//     312, // Guadeloupe\n//     316, // Guam\n//     320, // Guatemala\n//     324, // Guinea\n//     328, // Guyana\n//     332, // Haiti\n//     334, // Heard Island and McDonald Islands\n//     336, // Holy See\n//     340, // Honduras\n//     344, // Hong Kong\n//     348, // Hungary\n//     352, // Iceland\n//     356, // India\n//     360, // Indonesia\n//     364, // Iran (Islamic Republic of)\n//     368, // Iraq\n//     372, // Ireland\n//     376, // Israel\n//     380, // Italy\n//     384, // Cote d'Ivoire\n//     388, // Jamaica\n//     392, // Japan\n//     398, // Kazakhstan\n//     400, // Jordan\n//     404, // Kenya\n//     408, // Korea (Democratic People's Republic of)\n//     410, // Korea, Republic of\n//     414, // Kuwait\n//     417, // Kyrgyzstan\n//     418, // Lao People's Democratic Republic\n//     422, // Lebanon\n//     426, // Lesotho\n//     428, // Latvia\n//     430, // Liberia\n//     434, // Libya\n//     438, // Liechtenstein\n//     440, // Lithuania\n//     442, // Luxembourg\n//     446, // Macao\n//     450, // Madagascar\n//     454, // Malawi\n//     458, // Malaysia\n//     462, // Maldives\n//     466, // Mali\n//     470, // Malta\n//     474, // Martinique\n//     478, // Mauritania\n//     480, // Mauritius\n//     484, // Mexico\n//     492, // Monaco\n//     496, // Mongolia\n//     498, // Moldova, Republic of\n//     499, // Montenegro\n//     500, // Montserrat\n//     504, // Morocco\n//     508, // Mozambique\n//     512, // Oman\n//     516, // Namibia\n//     520, // Nauru\n//     524, // Nepal\n//     528, // Netherlands\n//     531, // Curacao\n//     533, // Aruba\n//     534, // Sint Maarten (Dutch part)\n//     535, // Bonaire, Sint Eustatius and Saba\n//     540, // New Caledonia\n//     548, // Vanuatu\n//     554, // New Zealand\n//     558, // Nicaragua\n//     562, // Niger\n//     566, // Nigeria\n//     570, // Niue\n//     574, // Norfolk Island\n//     578, // Norway\n//     580, // Northern Mariana Islands\n//     581, // United States Minor Outlying Islands\n//     583, // Micronesia (Federated States of)\n//     584, // Marshall Islands\n//     585, // Palau\n//     586, // Pakistan\n//     591, // Panama\n//     598, // Papua New Guinea\n//     600, // Paraguay\n//     604, // Peru\n//     608, // Philippines\n//     612, // Pitcairn\n//     616, // Poland\n//     620, // Portugal\n//     624, // Guinea-Bissau\n//     626, // Timor-Leste\n//     630, // Puerto Rico\n//     634, // Qatar\n//     638, // Reunion\n//     642, // Romania\n//     643, // Russian Federation\n//     646, // Rwanda\n//     652, // Saint Barthelemy\n//     654, // Saint Helena, Ascension and Tristan da Cunha\n//     659, // Saint Kitts and Nevis\n//     660, // Anguilla\n//     662, // Saint Lucia\n//     663, // Saint Martin (French part)\n//     666, // Saint Pierre and Miquelon\n//     670, // Saint Vincent and the Grenadines\n//     674, // San Marino\n//     678, // Sao Tome and Principe\n//     682, // Saudi Arabia\n//     686, // Senegal\n//     688, // Serbia\n//     690, // Seychelles\n//     694, // Sierra Leone\n//     702, // Singapore\n//     703, // Slovakia\n//     704, // Viet Nam\n//     705, // Slovenia\n//     706, // Somalia\n//     710, // South Africa\n//     716, // Zimbabwe\n//     724, // Spain\n//     728, // South Sudan\n//     729, // Sudan\n//     732, // Western Sahara\n//     740, // Suriname\n//     744, // Svalbard and Jan Mayen\n//     748, // Eswatini\n//     752, // Sweden\n//     756, // Switzerland\n//     760, // Syrian Arab Republic\n//     762, // Tajikistan\n//     764, // Thailand\n//     768, // Togo\n//     772, // Tokelau\n//     776, // Tonga\n//     780, // Trinidad and Tobago\n//     784, // United Arab Emirates\n//     788, // Tunisia\n//     792, // Turkiye\n//     795, // Turkmenistan\n//     796, // Turks and Caicos Islands\n//     798, // Tuvalu\n//     800, // Uganda\n//     804, // Ukraine\n//     807, // North Macedonia\n//     818, // Egypt\n//     826, // United Kingdom of Great Britain and Northern Ireland\n//     831, // Guernsey\n//     832, // Jersey\n//     833, // Isle of Man\n//     834, // Tanzania, United Republic of\n//     840, // United States of America\n//     850, // Virgin Islands (U.S.)\n//     854, // Burkina Faso\n//     858, // Uruguay\n//     860, // Uzbekistan\n//     862, // Venezuela (Bolivarian Republic of)\n//     876, // Wallis and Futuna\n//     882, // Samoa\n//     887, // Yemen\n//     894, // Zambia\n// ];\n","path":"/app/src/location.nr"},"62":{"source":"mod structs;\nmod location;\n\nuse structs::User;\n\nfn check_age(user1: User, user2: User) -> bool {\n    let mut is_match: bool = true;\n\n    // user1 preferences\n    if (user1.age < user2.preferences.age_min) | (user1.age > user2.preferences.age_max) {\n        is_match = false;\n    }\n\n    // user2 preferences\n    if (user2.age < user1.preferences.age_min) | (user2.age > user1.preferences.age_max) {\n        is_match = false;\n    }\n\n    is_match\n}\n\nfn check_gender(user1: User, user2: User) -> bool {\n    let mut is_match: bool = true;\n\n    // user1 preferences\n    if (user1.preferences.gender != user2.gender) & (user1.preferences.gender != 2) {\n        is_match = false;\n    }\n\n    // user2 preferences\n    if (user2.preferences.gender != user1.gender) & (user2.preferences.gender != 2) {\n        is_match = false;\n    }\n\n    is_match\n}\n\nfn check_interests(user1: User, user2: User) -> bool {\n    let mut is_match: bool = false;\n\n    for interest in user1.interests {\n        if user2.interests.any(|i| i == interest) {\n            is_match = true;\n        }\n    }\n    is_match\n}\n\nfn main(user1: User, user2: User) -> pub bool {\n    let id_nullifier_hash1 = std::hash::poseidon2::Poseidon2::hash([user1.id_nullifier], 1);\n    let id_nullifier_hash2 = std::hash::poseidon2::Poseidon2::hash([user2.id_nullifier], 1);\n    assert(user1.id == id_nullifier_hash1);\n    assert(user2.id == id_nullifier_hash2);\n\n    let mut is_match: bool = true;\n\n    is_match &= check_age(user1, user2);\n    is_match &= check_gender(user1, user2);\n    is_match &= location::check_region(user1, user2);\n    is_match &= check_interests(user1, user2);\n\n    is_match\n}\n","path":"/app/src/main.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}