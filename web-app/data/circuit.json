{
    "noir_version": "1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a",
    "hash": 13620580489347049584,
    "abi": {
        "parameters": [
            {
                "name": "user1",
                "type": {
                    "kind": "struct",
                    "path": "structs::User",
                    "fields": [
                        {
                            "name": "id",
                            "type": {
                                "kind": "field"
                            }
                        },
                        {
                            "name": "id_nullifier",
                            "type": {
                                "kind": "field"
                            }
                        },
                        {
                            "name": "age",
                            "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 8
                            }
                        },
                        {
                            "name": "gender",
                            "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 8
                            }
                        },
                        {
                            "name": "region",
                            "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 8
                            }
                        },
                        {
                            "name": "interests",
                            "type": {
                                "kind": "array",
                                "length": 3,
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 8
                                }
                            }
                        },
                        {
                            "name": "preferences",
                            "type": {
                                "kind": "struct",
                                "path": "structs::Preferences",
                                "fields": [
                                    {
                                        "name": "age_min",
                                        "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 8
                                        }
                                    },
                                    {
                                        "name": "age_max",
                                        "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 8
                                        }
                                    },
                                    {
                                        "name": "gender",
                                        "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 8
                                        }
                                    }
                                ]
                            }
                        }
                    ]
                },
                "visibility": "private"
            },
            {
                "name": "user2",
                "type": {
                    "kind": "struct",
                    "path": "structs::User",
                    "fields": [
                        {
                            "name": "id",
                            "type": {
                                "kind": "field"
                            }
                        },
                        {
                            "name": "id_nullifier",
                            "type": {
                                "kind": "field"
                            }
                        },
                        {
                            "name": "age",
                            "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 8
                            }
                        },
                        {
                            "name": "gender",
                            "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 8
                            }
                        },
                        {
                            "name": "region",
                            "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 8
                            }
                        },
                        {
                            "name": "interests",
                            "type": {
                                "kind": "array",
                                "length": 3,
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 8
                                }
                            }
                        },
                        {
                            "name": "preferences",
                            "type": {
                                "kind": "struct",
                                "path": "structs::Preferences",
                                "fields": [
                                    {
                                        "name": "age_min",
                                        "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 8
                                        }
                                    },
                                    {
                                        "name": "age_max",
                                        "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 8
                                        }
                                    },
                                    {
                                        "name": "gender",
                                        "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 8
                                        }
                                    }
                                ]
                            }
                        }
                    ]
                },
                "visibility": "private"
            }
        ],
        "return_type": {
            "abi_type": {
                "kind": "boolean"
            },
            "visibility": "public"
        },
        "error_types": {}
    },
    "bytecode": "H4sIAAAAAAAA/9VdC1cTRxS+2QTlUXyR+GhrWxARa8XZbEISrIpUK1SqFWqlWkGgyX/on+/pXpg552Y74JH9Ls7MOXsm3sDHdx/f3ZmRLBU6HPv59Y99Xcmvqp2T/Bot2KoeW81jG/HYznhsZz22UY9tzGMb99gmPbZzHtt5j+2Cx3bRY7vksU15bHWPrWFtclTsvGznzCy2Wv1Os59m6a5p9va6bdNq7y12027a7rb/bnazrN9tdTu9vV7H9NJW1k8H7V42MIfjisAyJYcmz6sn55kWDS4vNcGVr3/tfOWI11fta/d91/Lry/z6Kr++tnYf9hcnwL6eX9/k17f59Z2wu5EU4mvKjRSZq2ukU1NonyeAPl8H+ixrhyLK+wQwBtL3aU3np8EBmBbEUbiusSSkXxAJkPcUilc63AgI6XOOLeM6Y+cbRMN3YzYU78a1SIJ/Uqz+gIdJZ4C8bgAT9ynCKMs7Aea5TvEJY9bON4mGhcGGjwkj1OCXFcYs0MebFKcwRoG5maT4hDFn51tEw8Jgg7YwtIJfVhhzQB9v0ecRhik30jFgDGIUxrydbxMNC4MN2kspreCXFcY8kNdtcFFUwDmYs0WAPgz6HsdRxW9eLs8q+H0H7LcbVbD/40CfzwGxfgDG77hDGnQ9IXlLvnc1Cd9VwF0AFoOW3wsiwCDcUy02hHgPb3aDgeR7T5Mwg6P2NY78PSBHE3jhcgwN4e5YLoaGTueOVTamVWAsG0BeKcXZRJC8Jd+mJuGmAm5GYQuf/c5EgEG4p1psCMH57lgtTcIMjr5jtYAc24EXLsewTfg7Vpuwdyz0HjCzfqP3bFmgtbMYeD54uW8U8rFAYa4+O8r5MOVGymdDdxTy3A3cb9ZJR8HvHmEXBUcdvqPjUYNhDVoeuioH5kt2vu8C4g7M2VA8MEc3nBqhbqImXQIW4H2lRKKFskTYBhFynp3P54FYPxK20cgcH5d3U26kSN6S7wNNwg8UcB8Ci0HL74ciwCBcFa682ugRvkk9otNpUmV5jgBjeQHIa5nibFJI3pLvY03CjxVwVyjsJsU4KyLAINxoxHoRyOsnilOsSN6S7xNNwk8UcJ9S2GJlv5+KAINwoxHrJSCvnylOsSJ5S77PNAk/U8BdpbDFyn6vigCDcFUOlXkFwI0FvfdfoTCb8xrF0TzPAOOH3Jb8QnE2TyRvyfe5JuHnCrjrFHbzZL/XRYBBuNGIFbkt+ZXiFCuSt+T7QpPwCwXclxS2WNnvlyLAINxoxIrclvxGcYoVyVvyfaVJ+JUC7gaFLVb2e0MEGISrsi3hFQA3FvS2ZJ3CbM6byvkw5cZBbW8SvhkjNbMJxPodGDsNffDxwpqCPlaBWGtAf19THIuLs8D4Ibftf1Cciwskb8n3jSbhNwq4WxT24oL93hIBBuFGI1bktv1PilOsSN6S71tNwm8VcN9R2GJlv9+JAINwoxErctv+F8UpViRvyfe9JuH3CrjbFLZY2e9tEWAQrsq2nVcA3FjQ25ItCrM57yjnw5QbB7W9Q/hmjNTMDhDrAzB2jJGA4+aOUVAc+ZjitYLeNoBYyGOZXQpbb/xL348I31f3wH6j69r1GVQcP+QYuwp1vQ3EQvatfXB+3UDX4Rxh+6sWz/lIeM5EwnMWzFPj2Rf8UXB0X0M+UwP4cX+VGLqPl6NjiHySFvAhP0N6ScCx1Prkoyk5pM/o+tkH+uzjh1hD7Sv4fRmYH+bmDoEuF3LFNVq17/Ov1vPvsbi/U8OPIOUHa/GfBeC/AcKPEeXHGXLt8H8j8ek0H3rxk9r5odSNAnbx5zk9jBXmhvge5IOsHH5dB//g8LA4ZAzqBT8T8d4yiIPDc2vaEfr/SArvua8dLfCr4PmlRS5Vz89yY8rOdWFrHMF1XOAAc9p0+BM6+N6aGRevJwrvudzVPN9XOeLfSWE+7muPOxSe9LznMF2uJF/nx3++s6flbGsAAA==",
    "debug_symbols": "5ZvbiuMwDIbfJde9sCzLlvsqyzL0OARKW3pYWMq8+yZl7Clu0rLJaBgxd3Ws/0NyI/92oZdquZqfX1/q7Xp3rKa/LtVmt5id6t22GV0q4Ouz4362bYfH0+xwqqYAFCfVartsPloLb5NqXW9W1dTbt8ldMJJ/j3XW5FBLHaE2QOLagPg4GEJIYAiRngSbTAbj+Tb496SC+BOqtOZHVAmdVVqySYPg9FdpO6tEG3KVFG6rbDXYrQmQNM5AqXGdGgeUNUilhgZofLcm5tzo2bcGPi2uNVjigyyeZfFxNN4aTnhXrj0aWTzI4u1oPOY3E8mWeJTFO1k8jcdT2lIwuhLvZfFBFs+fsPYu4+9ezCiKd91dS5h9jogf48mntvKGSzzI4q0sHmXxbjTeAya8K7vWkSzey+LDaHyAFBvutjTHsvgoiicjix/ftSHvmIF9ibeyeJTFu09Ye8j48nhNJIvv6VprevCtJgzQ9PTXx9XFg31cRnT5QnlDhys9StK9EaWDKN2OpkNw+Q5hSzzK4p0snmTxPb3lXQ++1XT3lsfcW57ik7eBU2yMT0LRm7Q1oIePnQ07fzkwOW8D5T7iWWneUWfewSjNG5TmbZXmjUrzdkrzJqV5e6V5K/XLoNQvw9f6JeWjbZF3kwortUBWaoGs1AJZqQWyUgtkpRbISi2QlVogK7VAVnpljEr9Mir1y2i/zVEpClpgi3eyeKWGEpUaSlRqKFGpoUSlhtLMak1cqaWAUXoHA6P0EgbGaU1cqWuCUWqbYMK3OfCBYdEjGZgoy4ceawHu4V9FMETUs6UGzCKGOxEOEbkhIhoi8kNEYYiIh4ji/4qawfxQbzb168vtH0max39mh3o236zeh+vzdnEze/q7TzNJvz/sFqvl+bBqSde5Bv8P",
    "file_map": {
        "3": {
            "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n",
            "path": "std/array/mod.nr"
        },
        "25": {
            "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
            "path": "std/hash/poseidon2.nr"
        },
        "61": {
            "source": "use crate::structs::User;\n\npub fn check_region(user1: User, user2: User) -> bool {\n    assert(user1.region < regions.len() as u8);\n    let mut is_match: bool = true;\n\n    if user1.region != user2.region {\n        is_match = false;\n    }\n\n    is_match\n}\n\n// countries is too specific, so we use regions instead\n// the list is made up, with the help of ChatGPT\nglobal regions: [u8; 12] = [\n    001, // Northern Africa (ex: Egypt, Algeria, Morocco, ...)\n    002, // Sub-Saharan Africa (ex: Nigeria, Kenya, South Africa, ...)\n    003, // Middle East (ex: Israel, Saudi Arabia, Iran, ...)\n    004, // South Asia (ex: India, Pakistan, Bangladesh, ...)\n    005, // South-East Asia (ex: Indonesia, Vietnam, Philippines, ...)\n    006, // East Asia (ex: China, Japan, South Korea, ...)\n    007, // Central Asia (ex: Kazakhstan, Uzbekistan, Kyrgyzstan, ...)\n    008, // Eastern Europe (ex: Ukraine, Poland, Romania, ...)\n    009, // Western Europe (ex: France, Germany, Netherlands, ...)\n    010, // Southern Europe (ex: Italy, Spain, Greece, ...)\n    011, // North America (ex: United States, Canada, Mexico, ...)\n    012, // South America (ex: Brazil, Argentina, Colombia, ...)\n];\n\n// // ISO 3166-1\n// // https://www.iban.com/country-codes\n// global countries: [u16; 249] = [\n//     004, // Afghanistan\n//     008, // Albania\n//     010, // Antarctica\n//     012, // Algeria\n//     016, // American Samoa\n//     020, // Andorra\n//     024, // Angola\n//     028, // Antigua and Barbuda\n//     031, // Azerbaijan\n//     032, // Argentina\n//     036, // Australia\n//     040, // Austria\n//     044, // Bahamas\n//     048, // Bahrain\n//     050, // Bangladesh\n//     051, // Armenia\n//     052, // Barbados\n//     056, // Belgium\n//     060, // Bermuda\n//     064, // Bhutan\n//     068, // Bolivia (Plurinational State of)\n//     070, // Bosnia and Herzegovina\n//     072, // Botswana\n//     074, // Bouvet Island\n//     076, // Brazil\n//     084, // Belize\n//     086, // British Indian Ocean Territory\n//     090, // Solomon Islands\n//     092, // Virgin Islands (British)\n//     096, // Brunei Darussalam\n//     100, // Bulgaria\n//     104, // Myanmar\n//     108, // Burundi\n//     112, // Belarus\n//     116, // Cambodia\n//     120, // Cameroon\n//     124, // Canada\n//     132, // Cabo Verde\n//     136, // Cayman Islands\n//     140, // Central African Republic\n//     144, // Sri Lanka\n//     148, // Chad\n//     152, // Chile\n//     156, // China\n//     158, // Taiwan, Province of China\n//     162, // Christmas Island\n//     166, // Cocos (Keeling) Islands\n//     170, // Colombia\n//     174, // Comoros\n//     175, // Mayotte\n//     178, // Congo\n//     180, // Congo, Democratic Republic of the\n//     184, // Cook Islands\n//     188, // Costa Rica\n//     191, // Croatia\n//     192, // Cuba\n//     196, // Cyprus\n//     203, // Czechia\n//     204, // Benin\n//     208, // Denmark\n//     212, // Dominica\n//     214, // Dominican Republic\n//     218, // Ecuador\n//     222, // El Salvador\n//     226, // Equatorial Guinea\n//     231, // Ethiopia\n//     232, // Eritrea\n//     233, // Estonia\n//     234, // Faroe Islands\n//     238, // Falkland Islands (Malvinas)\n//     239, // South Georgia and the South Sandwich Islands\n//     242, // Fiji\n//     246, // Finland\n//     248, // Aland Islands\n//     250, // France\n//     254, // French Guiana\n//     258, // French Polynesia\n//     260, // French Southern Territories\n//     262, // Djibouti\n//     266, // Gabon\n//     268, // Georgia\n//     270, // Gambia\n//     275, // Palestine, State of\n//     276, // Germany\n//     288, // Ghana\n//     292, // Gibraltar\n//     296, // Kiribati\n//     300, // Greece\n//     304, // Greenland\n//     308, // Grenada\n//     312, // Guadeloupe\n//     316, // Guam\n//     320, // Guatemala\n//     324, // Guinea\n//     328, // Guyana\n//     332, // Haiti\n//     334, // Heard Island and McDonald Islands\n//     336, // Holy See\n//     340, // Honduras\n//     344, // Hong Kong\n//     348, // Hungary\n//     352, // Iceland\n//     356, // India\n//     360, // Indonesia\n//     364, // Iran (Islamic Republic of)\n//     368, // Iraq\n//     372, // Ireland\n//     376, // Israel\n//     380, // Italy\n//     384, // Cote d'Ivoire\n//     388, // Jamaica\n//     392, // Japan\n//     398, // Kazakhstan\n//     400, // Jordan\n//     404, // Kenya\n//     408, // Korea (Democratic People's Republic of)\n//     410, // Korea, Republic of\n//     414, // Kuwait\n//     417, // Kyrgyzstan\n//     418, // Lao People's Democratic Republic\n//     422, // Lebanon\n//     426, // Lesotho\n//     428, // Latvia\n//     430, // Liberia\n//     434, // Libya\n//     438, // Liechtenstein\n//     440, // Lithuania\n//     442, // Luxembourg\n//     446, // Macao\n//     450, // Madagascar\n//     454, // Malawi\n//     458, // Malaysia\n//     462, // Maldives\n//     466, // Mali\n//     470, // Malta\n//     474, // Martinique\n//     478, // Mauritania\n//     480, // Mauritius\n//     484, // Mexico\n//     492, // Monaco\n//     496, // Mongolia\n//     498, // Moldova, Republic of\n//     499, // Montenegro\n//     500, // Montserrat\n//     504, // Morocco\n//     508, // Mozambique\n//     512, // Oman\n//     516, // Namibia\n//     520, // Nauru\n//     524, // Nepal\n//     528, // Netherlands\n//     531, // Curacao\n//     533, // Aruba\n//     534, // Sint Maarten (Dutch part)\n//     535, // Bonaire, Sint Eustatius and Saba\n//     540, // New Caledonia\n//     548, // Vanuatu\n//     554, // New Zealand\n//     558, // Nicaragua\n//     562, // Niger\n//     566, // Nigeria\n//     570, // Niue\n//     574, // Norfolk Island\n//     578, // Norway\n//     580, // Northern Mariana Islands\n//     581, // United States Minor Outlying Islands\n//     583, // Micronesia (Federated States of)\n//     584, // Marshall Islands\n//     585, // Palau\n//     586, // Pakistan\n//     591, // Panama\n//     598, // Papua New Guinea\n//     600, // Paraguay\n//     604, // Peru\n//     608, // Philippines\n//     612, // Pitcairn\n//     616, // Poland\n//     620, // Portugal\n//     624, // Guinea-Bissau\n//     626, // Timor-Leste\n//     630, // Puerto Rico\n//     634, // Qatar\n//     638, // Reunion\n//     642, // Romania\n//     643, // Russian Federation\n//     646, // Rwanda\n//     652, // Saint Barthelemy\n//     654, // Saint Helena, Ascension and Tristan da Cunha\n//     659, // Saint Kitts and Nevis\n//     660, // Anguilla\n//     662, // Saint Lucia\n//     663, // Saint Martin (French part)\n//     666, // Saint Pierre and Miquelon\n//     670, // Saint Vincent and the Grenadines\n//     674, // San Marino\n//     678, // Sao Tome and Principe\n//     682, // Saudi Arabia\n//     686, // Senegal\n//     688, // Serbia\n//     690, // Seychelles\n//     694, // Sierra Leone\n//     702, // Singapore\n//     703, // Slovakia\n//     704, // Viet Nam\n//     705, // Slovenia\n//     706, // Somalia\n//     710, // South Africa\n//     716, // Zimbabwe\n//     724, // Spain\n//     728, // South Sudan\n//     729, // Sudan\n//     732, // Western Sahara\n//     740, // Suriname\n//     744, // Svalbard and Jan Mayen\n//     748, // Eswatini\n//     752, // Sweden\n//     756, // Switzerland\n//     760, // Syrian Arab Republic\n//     762, // Tajikistan\n//     764, // Thailand\n//     768, // Togo\n//     772, // Tokelau\n//     776, // Tonga\n//     780, // Trinidad and Tobago\n//     784, // United Arab Emirates\n//     788, // Tunisia\n//     792, // Turkiye\n//     795, // Turkmenistan\n//     796, // Turks and Caicos Islands\n//     798, // Tuvalu\n//     800, // Uganda\n//     804, // Ukraine\n//     807, // North Macedonia\n//     818, // Egypt\n//     826, // United Kingdom of Great Britain and Northern Ireland\n//     831, // Guernsey\n//     832, // Jersey\n//     833, // Isle of Man\n//     834, // Tanzania, United Republic of\n//     840, // United States of America\n//     850, // Virgin Islands (U.S.)\n//     854, // Burkina Faso\n//     858, // Uruguay\n//     860, // Uzbekistan\n//     862, // Venezuela (Bolivarian Republic of)\n//     876, // Wallis and Futuna\n//     882, // Samoa\n//     887, // Yemen\n//     894, // Zambia\n// ];\n",
            "path": "/app/src/location.nr"
        },
        "62": {
            "source": "mod structs;\nmod location;\n\nuse structs::User;\n\nfn check_age(user1: User, user2: User) -> bool {\n    let mut is_match: bool = true;\n\n    // user1 preferences\n    if (user1.age < user2.preferences.age_min) | (user1.age > user2.preferences.age_max) {\n        is_match = false;\n    }\n\n    // user2 preferences\n    if (user2.age < user1.preferences.age_min) | (user2.age > user1.preferences.age_max) {\n        is_match = false;\n    }\n\n    is_match\n}\n\nfn check_gender(user1: User, user2: User) -> bool {\n    let mut is_match: bool = true;\n\n    // user1 preferences\n    if (user1.preferences.gender != user2.gender) & (user1.preferences.gender != 2) {\n        is_match = false;\n    }\n\n    // user2 preferences\n    if (user2.preferences.gender != user1.gender) & (user2.preferences.gender != 2) {\n        is_match = false;\n    }\n\n    is_match\n}\n\nfn check_interests(user1: User, user2: User) -> bool {\n    let mut is_match: bool = false;\n\n    for interest in user1.interests {\n        if user2.interests.any(|i| i == interest) {\n            is_match = true;\n        }\n    }\n    is_match\n}\n\nfn main(user1: User, user2: User) -> pub bool {\n    let id_nullifier_hash1 = std::hash::poseidon2::Poseidon2::hash([user1.id_nullifier], 1);\n    let id_nullifier_hash2 = std::hash::poseidon2::Poseidon2::hash([user2.id_nullifier], 1);\n    assert(user1.id == id_nullifier_hash1);\n    assert(user2.id == id_nullifier_hash2);\n    assert(user1.id != user2.id);\n\n    let mut is_match: bool = true;\n\n    is_match &= check_age(user1, user2);\n    is_match &= check_gender(user1, user2);\n    is_match &= location::check_region(user1, user2);\n    is_match &= check_interests(user1, user2);\n\n    assert(is_match);\n    is_match\n}\n",
            "path": "/app/src/main.nr"
        }
    },
    "names": [
        "main"
    ],
    "brillig_names": [
        "directive_invert",
        "directive_integer_quotient"
    ]
}