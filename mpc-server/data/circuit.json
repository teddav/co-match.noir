{
    "noir_version": "1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a",
    "hash": 17131741431201876131,
    "abi": {
        "parameters": [
            {
                "name": "user1",
                "type": {
                    "kind": "struct",
                    "path": "structs::User",
                    "fields": [
                        {
                            "name": "id",
                            "type": {
                                "kind": "field"
                            }
                        },
                        {
                            "name": "age",
                            "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 8
                            }
                        },
                        {
                            "name": "gender",
                            "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 8
                            }
                        },
                        {
                            "name": "region",
                            "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 8
                            }
                        },
                        {
                            "name": "interests",
                            "type": {
                                "kind": "array",
                                "length": 3,
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 8
                                }
                            }
                        },
                        {
                            "name": "preferences",
                            "type": {
                                "kind": "struct",
                                "path": "structs::Preferences",
                                "fields": [
                                    {
                                        "name": "age_min",
                                        "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 8
                                        }
                                    },
                                    {
                                        "name": "age_max",
                                        "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 8
                                        }
                                    },
                                    {
                                        "name": "gender",
                                        "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 8
                                        }
                                    }
                                ]
                            }
                        }
                    ]
                },
                "visibility": "private"
            },
            {
                "name": "user2",
                "type": {
                    "kind": "struct",
                    "path": "structs::User",
                    "fields": [
                        {
                            "name": "id",
                            "type": {
                                "kind": "field"
                            }
                        },
                        {
                            "name": "age",
                            "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 8
                            }
                        },
                        {
                            "name": "gender",
                            "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 8
                            }
                        },
                        {
                            "name": "region",
                            "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 8
                            }
                        },
                        {
                            "name": "interests",
                            "type": {
                                "kind": "array",
                                "length": 3,
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 8
                                }
                            }
                        },
                        {
                            "name": "preferences",
                            "type": {
                                "kind": "struct",
                                "path": "structs::Preferences",
                                "fields": [
                                    {
                                        "name": "age_min",
                                        "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 8
                                        }
                                    },
                                    {
                                        "name": "age_max",
                                        "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 8
                                        }
                                    },
                                    {
                                        "name": "gender",
                                        "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 8
                                        }
                                    }
                                ]
                            }
                        }
                    ]
                },
                "visibility": "private"
            }
        ],
        "return_type": {
            "abi_type": {
                "kind": "boolean"
            },
            "visibility": "public"
        },
        "error_types": {}
    },
    "bytecode": "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",
    "debug_symbols": "1ZvbbuJADIbfJddc2J5zX2W1qjiEKhICxGGlFeq7b8KSQAfSqkn/qr5jyPyfnUzssSPNqViUs+PLc7VebvbF069TsdrMp4dqs65Hp4Lj+b/9drpuhvvDdHcontgTT4pyvWh+Cr9OimW1KosnL6+/JwWnz2uEHmtCaDWB6FYzuZ9sO36IOZ6xeMHizXh8NJe5IpTjLRbvsHg/Gi/eXeYakhwfsPiIxafReEPtXGNthjeExTMWL1/w7G2HdzneYPGPozZw7PBv7/geb5O/zHVscrzD4j0WH7D4OBrvpH0N3P2LmaB4S1g8Y/EyHu/auS6GHG+weIvFOyx+fNReq0Bv8q3cBiw+YvEJinfjo9b7NqwC5UvrGIsXLN5g8eOjNrC0eJs3P85h8R6LHx+1kdv3Pro7fMTiExTvCYsfH7XRtXVOjHmN6QWLN1i8/YJnTx3e53iHxfdELfkefKMJAzQ98eWl06T4/m2ktkthuZnJZ3pC0gNB6Qyly2h6vZrtZ5Hbzv8/3mDxFot3WHxPbDnqwTeax7EVuYut+LZHf+ASdd+xmFIe8CGiDSSwgUhoAzzeAHc5l1nS+5PNtSA3nq/emIdg0wU727yCjKLWc6PWc6vWc6fWc6/W86DW86jW86TV80RqPVe7hya1e2j67j3UdY1H5nnjjAVXacmhDXi0AXStn9Sm7KQ2ZTOpzdlMapM2k9qszaS29WGyel1X2/wwqe1+mNS2P/VOq9d1vbsp0w+qaWsS0puzBYFbMOCqs15GuAUHt+DhFvSmQtabCllvKhS9jYXobSxEb2MhehsL0dtYiN7GQvQ2FqJ3NxW9u6mkn1SdG0LXzgZe//ecFolkeyycRWaIqCfFutSJ/N2C95zX+EDkh4jCEFEcIkoDRD2nGz4Q8WdF9WC2q1ar6uX59sBk/fef6a6azlblZbg8ruc3Vw9/t+2VVr/dbebl4rgrG9L5Wo3/Bw==",
    "file_map": {
        "3": {
            "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n",
            "path": "std/array/mod.nr"
        },
        "61": {
            "source": "use crate::structs::User;\n\npub fn check_region(user1: User, user2: User) -> bool {\n    assert(user1.region < regions.len() as u8);\n    let mut is_match: bool = true;\n\n    if user1.region != user2.region {\n        is_match = false;\n    }\n\n    is_match\n}\n\nglobal regions: [u8; 4] = [001, 002, 003, 004];\n",
            "path": "/app/src/location.nr"
        },
        "62": {
            "source": "mod structs;\nmod location;\n\nuse structs::User;\n\nfn check_age(user1: User, user2: User) -> bool {\n    let mut is_match: bool = true;\n\n    if (user1.age < user2.preferences.age_min) | (user1.age > user2.preferences.age_max) {\n        is_match = false;\n    }\n\n    if (user2.age < user1.preferences.age_min) | (user2.age > user1.preferences.age_max) {\n        is_match = false;\n    }\n\n    is_match\n}\n\nfn check_gender(user1: User, user2: User) -> bool {\n    let mut is_match: bool = true;\n\n    assert(user1.gender <= 1);\n    assert(user2.gender <= 1);\n    assert(user1.preferences.gender <= 2);\n    assert(user2.preferences.gender <= 2);\n\n    // user1 preferences\n    if (user1.preferences.gender != user2.gender) & (user1.preferences.gender != 2) {\n        is_match = false;\n    }\n\n    // user2 preferences\n    if (user2.preferences.gender != user1.gender) & (user2.preferences.gender != 2) {\n        is_match = false;\n    }\n\n    is_match\n}\n\nfn check_interests(user1: User, user2: User) -> bool {\n    let mut is_match: bool = false;\n\n    for interest in user1.interests {\n        assert(interest <= 8);\n        if user2.interests.any(|i| i == interest) {\n            is_match = true;\n        }\n    }\n    is_match\n}\n\nfn main(user1: User, user2: User) -> pub bool {\n    // removed hash to make circuit smaller\n    // let id_nullifier_hash1 = std::hash::poseidon2::Poseidon2::hash([user1.id_nullifier], 1);\n    // let id_nullifier_hash2 = std::hash::poseidon2::Poseidon2::hash([user2.id_nullifier], 1);\n    // assert(user1.id == id_nullifier_hash1);\n    // assert(user2.id == id_nullifier_hash2);\n    assert(user1.id != user2.id);\n\n    let mut is_match: bool = true;\n\n    is_match &= check_age(user1, user2);\n    is_match &= check_gender(user1, user2);\n    is_match &= location::check_region(user1, user2);\n    is_match &= check_interests(user1, user2);\n\n    assert(is_match);\n    is_match\n}\n",
            "path": "/app/src/main.nr"
        }
    },
    "names": [
        "main"
    ],
    "brillig_names": [
        "directive_invert",
        "directive_integer_quotient"
    ]
}